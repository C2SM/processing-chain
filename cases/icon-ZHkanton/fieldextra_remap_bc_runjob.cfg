#!/usr/bin/env bash
#SBATCH --job-name="{cfg.casename}_{cfg.inidate_yyyymmddhh}_{cfg.forecasttime}.remapBC"
#SBATCH --account={cfg.compute_account}
#SBATCH --chdir={cfg.icon_work}
#SBATCH --partition=debug ##{cfg.compute_queue}
#SBATCH --constraint={cfg.constraint}
#SBATCH --nodes=1
#SBATCH --ntasks-per-core=1
#SBATCH --ntasks-per-node={cfg.ntasks_per_node}
#SBATCH --cpus-per-task=1
#SBATCH --output={logfile}
#SBATCH --open-mode=append

ulimit -s unlimited       # unlimit stack size
export OMP_STACKSIZE=500M # increase OpenMP stack size

set -x

#=============================================================================
# Write namelist
#=============================================================================

cat > NAMELIST_FIELDEXTRA_BC << EOF
!##############################################
!
! Generate the boundary condition for the control run of ICON on the ICON triangular grid
! from COSMO data, using radial basis function interpolation for scalar and vector fields.
!
! Data is read as COSMO, and re-gridded and written as ICON, using the in_model_name -
! out_model_name mechanism.
!
!##############################################


&RunSpecification
 strict_usage          = .true.
 verbosity             = "moderate"
 additional_diagnostic = .false.
 additional_profiling  = .false.
 n_ompthread_total     = 12
 n_ompthread_collect   = 1
 n_ompthread_generate  = 1
/

!----------------------------------------------------------------------------------
! COSMO data is decoded with the help of dictionary_cosmo, and encoded as ICON data
! using dictionary_icon. Therefore, both dictionaries have to be specified.
!----------------------------------------------------------------------------------
&GlobalResource
 dictionary            = "/project/s83c/fieldextra/daint/resources/dictionary_icon.txt",
                         "/project/s83c/fieldextra/daint/resources/dictionary_cosmo.txt"
 grib_definition_path  = "/project/s83c/fieldextra/daint/resources/eccodes_definitions_cosmo",
                         "/project/s83c/fieldextra/daint/resources/eccodes_definitions_vendor"
 grib2_sample          = "/project/s83c/fieldextra/daint/resources/eccodes_samples/COSMO_GRIB2_default.tmpl"
 icon_grid_description = "{cfg.dynamics_grid_filename_scratch}",
                         "{cfg.lateral_boundary_grid_scratch}"
/

!----------------------------------------------------------------------------------
! ICON is set as the default_model_name here, but since in_model_name and
! out_model_name are explicitely set in the I/O blocks, the default_model_name is
! actually not used in this example.
!----------------------------------------------------------------------------------
&GlobalSettings
  default_model_name            = "icon"
  !default_out_type_stdlongitude = .true.
/

&ModelSpecification
 model_name         = "cosmo"
 earth_axis_large   = 6371229.
 earth_axis_small   = 6371229.
/

! Radial basis function interpolation will be used as regrid_method to the ICON triangular
! grid for all fields.
!
&ModelSpecification
  model_name                = "icon"
  earth_axis_large          = 6371229.
  earth_axis_small          = 6371229.
  regrid_method             = "__ALL__:icontools,rbf"
/

!----------------------------------------------------------------------------------
! Use INCORE storage to tag the COSMO mass point grid for the re-gridding of U and V
!----------------------------------------------------------------------------------
&Process
  in_file = "{cfg.input_root_icbc}/{cfg.icbc_prefix}{cfg.inidate_yyyymmddhh}{cfg.icbc_suffix}"
  in_model_name="cosmo"
  out_type = "INCORE"
/
&Process in_field = "HSURF", tag="GRID_cosmo" /

!----------------------------------------------------------------------------------
! Read all necessary COSMO input fields.
! Rotate U and V, such that they refer to the geographical reference system.
! Scalar fields are re-gridded on output to the cell subgrid of the ICON triangular grid, which is
! specified in ../../resources/grid_descriptions/ICON-1E_DOM01_R19B08.nc.
! Radial basis function interpolation for vector fields is used to compute the edge normal wind
! component VN at the edge midpoints of the ICON grid from the horizontal wind compnents U and V.
! Note that out_model_name is set in the programme before the re-gridding takes place. Thus the default
! regrid_method that is defined in the ModelSpecification of ICON is used (and must be defined there).
!----------------------------------------------------------------------------------
&Process
  in_file = "{cfg.input_root_icbc}/{cfg.icbc_prefix}<yyyymmddhh:{cfg.inidate_yyyymmddhh}>"
  tstart=0, tstop={cfg.hstop}, tincr={cfg.icbc_incr}
  in_model_name="cosmo"
  in_regrid_target="GRID_cosmo"
  in_regrid_method="average,square,0.9" ! only needed for U,V regridding with n2geog
  out_regrid_target = "icon_grid,cell,{cfg.lateral_boundary_grid_scratch}"
  out_regrid_method = "default"
  out_file = '{cfg.icon_input_icbc}/{cfg.latbc_prefix}<yyyymmddhh:{cfg.inidate_yyyymmddhh}>{cfg.latbc_suffix}'
  out_model_name = "icon"
  out_type = "NETCDF", out_type_ncaspect="icon", out_type_nousetag=.true.
/

&Process in_field = "HEIGHT", level_class="k_half", levmin=1, levmax=81 /
&Process in_field = "U",  levmin=1, levmax=80, regrid=.t., poper="n2geog" /
&Process in_field = "V",  levmin=1, levmax=80, regrid=.t., poper="n2geog" /
!&Process in_field = "U",  levmin=1, levmax=80 /
!&Process in_field = "V",  levmin=1, levmax=80 /
&Process in_field = "W",  levmin=1, levmax=81 /
&Process in_field = "T",  levmin=1, levmax=80 /
&Process in_field = "P",  levmin=1, levmax=80 /
&Process in_field = "QV", levmin=1, levmax=80 /
&Process in_field = "QC", levmin=1, levmax=80 /
&Process in_field = "QI", levmin=1, levmax=80 /
&Process in_field = "QR", levmin=1, levmax=80 /
&Process in_field = "QS", levmin=1, levmax=80 /
&Process in_field = "QG", levmin=1, levmax=80 /
! &Process in_field = "PS" /
! &Process in_field = "FIS" /


&Process out_field = "HEIGHT", level_class="k_half", levmin=1, levmax=81 /
&Process out_field = "U",  levmin=1, levmax=80 /
&Process out_field = "V",  levmin=1, levmax=80 /
!&Process out_field = "U",  levmin=1, levmax=80, regrid_operator="U,V>VN" /
!&Process out_field = "V",  levmin=1, levmax=80, regrid_operator="U,V>VN" /
&Process out_field = "W",  levmin=1, levmax=81 /
&Process out_field = "T",  levmin=1, levmax=80 /
&Process out_field = "P",  levmin=1, levmax=80 /
&Process out_field = "QV", levmin=1, levmax=80 /
&Process out_field = "QC", levmin=1, levmax=80 /
&Process out_field = "QI", levmin=1, levmax=80 /
&Process out_field = "QR", levmin=1, levmax=80 /
&Process out_field = "QS", levmin=1, levmax=80 /
&Process out_field = "QG", levmin=1, levmax=80 /
! &Process out_field = "PS" / ! see figure 6.3 in the tutorial: if provided HHL -> read HHL, P, T, W
! &Process out_field = "FIS" / ! ignoring PS,GEOP,T. This way W is W and not OMEGA

EOF

#=============================================================================
# Run
#=============================================================================

srun -n 1 {cfg.fieldextra_bin} \
    NAMELIST_FIELDEXTRA_BC 2>&1

#=============================================================================
# clean-up
#=============================================================================

rm -f fieldextra.diagnostic

#=============================================================================
exit
#=============================================================================
